Алгоритм неустойчивой сортировки.
Сложность O(n \log{n}) — среднее время, O(n^2) — худший случай.

Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива или же число, вычисленное на основе 
значений элементов; от выбора этого числа сильно зависит эффективность алгоритма.
Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, 
следующие друг за другом: «меньшие опорного», «равные» и «большие».
Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Плюсы:
Один из самых быстродействующих (на практике) из алгоритмов внутренней сортировки общего назначения.
Прост в реализации.
Требует лишь O(lg n) дополнительной памяти для своей работы. (Не улучшенный рекурсивный алгоритм в худшем случае O(n \log n) памяти)
Хорошо сочетается с механизмами кэширования и виртуальной памяти.
Допускает естественное распараллеливание (сортировка выделенных подмассивов в параллельно выполняющихся подпроцессах).
Допускает эффективную модификацию для сортировки по нескольким ключам (в частности — алгоритм Седжвика для сортировки строк): 
благодаря тому, что в процессе разделения автоматически выделяется отрезок элементов, равных опорному, этот отрезок можно сразу
же сортировать по следующему ключу.
Работает на связных списках и других структурах с последовательным доступом, допускающих эффективный проход как от начала к концу,
так и от конца к началу.

Минусы:
Сильно деградирует по скорости (до O(n^2)) в худшем или близком к нему случае, что может случиться при неудачных входных данных.
Прямая реализация в виде функции с двумя рекурсивными вызовами может привести к ошибке переполнения стека, так как в худшем случае ей может потребоваться сделать O(n) вложенных рекурсивных вызовов.
Неустойчив.
